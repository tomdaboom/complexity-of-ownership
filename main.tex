\documentclass{article}
\usepackage{graphicx} % Required for inserting images

\usepackage[a4paper, total={7in, 10.5in}]{geometry}
\usepackage{hyperref}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

%\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{assumption}[theorem]{Assumption}

\AtBeginEnvironment{definition}{\renewcommand\em{\bfseries\textit}}
\renewcommand\em{\bfseries}

\newcommand{\agap}{\hspace{0.25em}}
\newcommand{\mkref}{\textbf{ref}~}
\newcommand{\deref}{\textbf{deref}~}%{\mathbf{*}}
\newcommand{\drfStar}{*\hspace{0.07em}}
\newcommand{\mutate}[3]{\textbf{mut}~ #1 \Rightarrow #2 ~\textbf{then}~ #3}
\newcommand{\mutptr}[3]{\textbf{mutAt}~ #1 \Rightarrow #2 ~\textbf{then}~ #3}

\newcommand{\letvar}[3]{\textbf{let}~ #1 \Leftarrow #2 ~\textbf{then}~ #3}
\newcommand{\parfun}{\rightharpoonup}
\newcommand{\red}{\leadsto}
\newcommand{\bvdash}{\mathbin{\rotatebox[origin=c]{180}{$\vdash$}}}
\newcommand{\lolly}{\multimap}
\newcommand{\judge}[3]{\textsc{#1}&\frac{#2}{#3}}


\usepackage[backend=biber, maxnames=10]{biblatex}
\addbibresource{./ref.bib}

\title{The Ownership Problem and its Algorithmic Complexity}
\author{\href{mailto:oi24939@bristol.ac.uk}{\texttt{Tom.Divers@bristol.ac.uk}}}
\date{}
 
\begin{document}

\maketitle

\section{Introduction}

\subsection{C to Rust Translation}

\cite{zhang2023crown}

\subsection{The Borrow Checker}

\subsection{Problem Statement}

\section{A Language with Pointers and Mutation}

We begin by defining a simple imperative language with references. This language is intended to encapsulate C's pointer system, without enforcing any of the memory safety rules enforced by Rust. Later on, we will define an alternate type system for this language which \textit{does} enforce Rust's ownership and borrowing constraints.

\subsection{Syntax and Types}

We define our access paths, types and programs as follows (assuming the existence of some infinite set of variable identifiers $V$):
\begin{align*}
    P ::=~ &x \in V ~|~ \drfStar \! P ~|~ P.\textbf{fst} ~|~ P.\textbf{snd}\\
    ~\\
    \tau, \sigma ::=~ &\textbf{Int} ~|~ \tau \times \sigma ~|~ \tau \rightarrow \sigma
    ~\\
    M ::= &
\end{align*}

Observe that the following program typechecks in this language:
\begin{align*}
    =
\end{align*}
A C analogue of this program would compile without any errors. In Rust, however, the borrow checker complains about two problems that violate memory safety. 

Initially, $y$ and $z$ both \textit{borrow} $x$'s value. Because $y$ and $z$ both both borrow $x$ simultaneously, this borrow must be \textit{immutable}. The first issue follows: Rust complains when the value pointed to by $y$ is mutated. The second issue concerns $y$'s dereference: when $y$ is dereferenced, the value of $x$ is \textit{moved} into $\deref y$,\footnote{We assume that the \textbf{Int} type we are using does not implement the \texttt{Clone} trait, meaning that the \texttt{.clone()} method is not called implicitly here.} meaning that $x$ is no longer owning at that point. Hence, the borrow checker complains when we try and move $x$ when $z$ is dereferenced. 

Our problem is therefore to decide whether or not a program in this language makes the borrow checker complain. Obviously, this is a nebulous question, with a precise definition that we nail down in the next section. In order to do this, we introduce an alternate type system for our language, which enforces that a well-typed program satisfies some of Rust's borrow-checking constraints.


\subsection{Semantics}



\section{Memory-safe Type Systems}


\subsection{Permissions as Fractional Grades}

\subsection{Our System}







\renewcommand\em{\it}
\printbibliography[title={References}]

\end{document}